# stipple.py

import support
import numpy as np
import os
from PIL import Image, ImageDraw
import random
import math
import re


# PARAMATERS #
N = 1500 # Number of points
pointsGen = 'random' # grid, random, file
npy_file = "" # file of numpy file if pointsGen = file
thresh = 0.5 #Threshold of difference between old center and new center


## Required API ##

# Takes a numpy matrix/image and produces a stippled image of the orignal
# Result represents the original image by plotting regions of dots of varying density
#
# Returns 2 things:
#   resultPoints - a plot of regions of dots of varying density
#   resultCells - a plot of the Voroni cells (drawVoroniCells)
#
# Algorithm:
#   while generating points xi not converged to centroids
#       Compute the voroni diagram of xi
#       Compute the centroids Ci
#       Move each generating point xi to its centroid Ci
def stipple(image):
  rows, cols = support.getSize(image)
  image = (image*-1) + 255
  image = image / 255

  avg_dist = 100 # large value to start
  points = generatePoints(image)
  P = computeP(image)
  Q = computeQ(P)
  while avg_dist > thresh:

    
    # create points.txt
    writePoints(points, rows, cols)

    edges = getVoroniEdges()
    lakes = generateLakes(points)

    avg_dist = computeCentroids(lakes, edges, P, Q, rows, cols)
    print "Average Distance", avg_dist

    points = []
    for lake in lakes:
      points.append(lake.centroid)


    edgeList = []
    for edge in edges:
      edgeList.append(edge.top)
      edgeList.append(edge.bot)

    resultCells = drawVoronoiCells(rows, cols, edgeList)

  return points, resultCells



# Generates a list of N points based on the global parameter pointsGen
# Generates points.txt which is used to calculate voroni diagrams
def generatePoints(image):
  rows, cols = support.getSize(image)
  
  if pointsGen == 'grid':
    size = math.sqrt(N)
    r_step = int(rows/size)
    r_init = r_step/2
    c_step = int(cols/size)
    c_init = c_step/2

    # Find points
    pointsList = []
    for r in range (r_init, rows-1, r_step):
      for c in range(c_init, cols-1, c_step):
        pointsList.append([r,c])

    return pointsList

  elif pointsGen == 'random':
    chosenPoints = {}
    while len(chosenPoints) < N:
      r = random.randint(10,rows-10)
      c = random.randint(10,cols-10)
      # if r,c is not already a chosen point
      value = (r,c)
      if value not in chosenPoints:
        chosenPoints[r,c] = support.makeVector(r,c)

    pointsList = []
    for key, value in chosenPoints.iteritems():
      pointsList.append(value)

    pointsList.sort(cmp=comparePoints)

    return pointsList

  elif pointsGen == 'file':
    matrix = support.loadMatrix(npy_file)
    rows, cols = support.getSize(matrix)
    pointsList = []
    for r in range(0, rows, 1):
      value = matrix[r,0]
      pointsList.append(value)

    return pointsList
    


# Creates an image of the Voronoi cells represented by the edges in the given edgeList
# Takes a white (255) PIL image on which it draws the Voroni edges in black by drawing short lines
def drawVoronoiCells(rows, cols, edgeList):
  size = cols,rows
  im = Image.new("L", size, 255)
  draw = ImageDraw.Draw(im)
  i = 0
  while i < len(edgeList):
    edge1 = edgeList[i]
    edge2 = edgeList[i+1]
    draw.line([(edge1[1], edge1[0]),(edge2[1], edge2[0])])
    i = i + 2

  #support.showImage(im)

  matrix = support.img2mat(im)
  matrix[ matrix==255 ] = -1
  return matrix



## Other Functions ##

def writePoints(points, rows, cols):
  # sort points
  points.sort(cmp=comparePoints)
  
  f = file("points.txt", "w")
  print >> f, "DIMS %d %d" % (rows, cols)
  for p in points:
    print >> f, "%d %d" % (p[0], p[1])
  

# Returns list of edges generated by genPoints as generators for voronoi diagram
def getVoroniEdges():
  edges = []

  # Calculate voroni edges
  os.system("voronoi points.txt edges.txt")

  # Read edges.txt
  f = file("edges.txt")
  line = f.readline().strip()

  while line != "":
    v = line.split()
    v = map(float, v)
    edges.append(Edge(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8]))
    line = f.readline()

  return edges


def generateLakes(points):
  lakes = []
  i = 0
  for p in points:
    lakes.append(Lake(p, i))
    i = i + 1

  return lakes
  

# for each row
#   intersect the edges with horizontal line through the row
#   re-sort the lines based on the coordinate of the intersection
#   keep only the good intersections
#   compute the density contributions between intersections
def computeCentroids(lakes, edges, P, Q, rows, cols):
  print("Computing Centroids")

  allEdges = list(edges)

  for r in range (0,rows,1):
    if r % 20 == 0:
      print("row", r)

    
    # set intersections and remove unneeded edges
    edges = list(allEdges)
    i = 0
    while i < len(edges):
      edge = edges[i]
      edge.setIntersection(r)
      if not edge.isRealEdge(r, cols):
        edges.remove(edge)
      else:
        i = i + 1
    edges.sort(cmp=compareEdges)

    c1 = 1
    edgeCount = len(edges)
    for i in range (0, edgeCount+1, 1):
      lake_num = 0
      if i < edgeCount:
        edge = edges[i]
        c2 = edge.sect
        lake_num = edge.lF
        
  
      else: # i == edgeCount
        edge = edges[i-1]
        c2 = cols-1
        lake_num = edge.rF
      lakes[lake_num].addToCentroid(P,Q,r,c1,c2)
      c1 = c2+1
      
  tot_dist = 0
  print "Updating Centroids"
  for lake in lakes:
    tot_dist = tot_dist + lake.updateCentroid()

  return tot_dist / len(lakes)
    

# Used to calculate the matrix P, input image matrix
def computeP(I):
  rows, cols = support.getSize(I)
  P = support.makeMatrix(rows,cols)
  P[0:rows,0] = I[0:rows,0]
  for r in range (0,rows,1):
    for c in range (1,cols,1):
      P[r,c] = I[r,c] + P[r,c-1]
  return P

# Used to calculate the matrix Q, input P matrix
def computeQ(P):
  rows, cols = support.getSize(P)
  Q = support.makeMatrix(rows,cols)
  Q[0:rows,1] = P[0:rows,0]
  for r in range (0,rows,1):
    for c in range (2,cols,1):
      Q[r,c] = P[r,c-1] + Q[r,c-1]

  return Q


# if the column coordinates of two intersections differ, the edge with lower value comes first
# if "" "" are the same, there could be several edges at that point
#    compute this quantity using the edge vectors oriented from the top to the bottom point
#    v2.r*v1.c - v1.r*v2.c
#       v1 - e1 topPt, botPt
#       v2 - e2 topPt, botPt
#    if < 0 edges are ordered correctly
#    if > 0 edges are in opposite order
#    if == 0 edges are equivalent
def compareEdges(e1,e2):
  if e1.sect != e2.sect:
    if e1.sect < e2.sect:
      return -1
    else:
      return +1
  else:
    v1 = e1.bot - e1.top
    v2 = e2.bot - e2.top
    value = v2[0]*v1[1]-v1[0]*v2[1]
    if value < 0:
      return -1
    elif value > 0:
      return +1
    else:
      return 0

def comparePoints(p1, p2):
  r1 = p1[0]
  c1 = p1[1]
  r2 = p2[0]
  c2 = p2[1]
  if r1 < r2:
    return -1
  elif r1 > r2:
    return +1
  else: #r1 == r2
    if c1 < c2:
      return -1
    elif c1 > c2:
      return +1
    else:
      return 0


def getPointDist(v1, v2):
    v = v2 - v1
    return math.sqrt(v[0]*v[0] + v[1]*v[1])


## Classes ##

# Line = a(row) + b(col) + c = 0
class Edge:

  def __init__(self, lF, rF, tpr, tpc, bpr, bpc, a, b, c):
    self.lF = int(lF)    # Left Face
    self.rF = int(rF)    # Right Face
    self.top = support.makeVector(tpr,tpc)
    self.top = np.round(self.top)
    self.bot = support.makeVector(bpr,bpc)
    self.bot = np.round(self.bot)
    self.a = a
    self.b = b
    self.c = c
    self.sect = 0

  # Sets the intersection class member
  def setIntersection(self, row):
    self.sect = round(-((self.a * row) + self.c)/self.b)
    

  # Return True if the edge appears in row; False otherwise
  def isRealEdge(self, row, cols):
    if row >= self.top[0] and row <= self.bot[0]:
      if self.sect >= 0 and self.sect < cols: #probably shouldn't need this!
        return True
    return False


class Lake:
  def __init__(self, center, num):
    self.num = num
    self.denom = 0
    self.rNum = 0
    self.cNum = 0
    self.centroid = center

  def addToCentroid(self, P, Q, r, c1, c2):

    # Inclusive rather than exclusive
    c1 = c1 - 1
    P1 = P[r,c1]
    P2 = P[r,c2]
    Q1 = Q[r,c1]
    Q2 = Q[r,c2]

    self.denom = self.denom + P2 - P1
    self.rNum = self.rNum + (r * (P2 - P1))
    self.cNum = self.cNum + (c2*P2 - Q2) - (c1*P1 - Q1)

  # Returns the distance moved from the previous center
  def updateCentroid(self):
    prev_center = self.centroid
    self.centroid =  support.makeVector(round(self.rNum/self.denom), round(self.cNum/self.denom))
    return getPointDist(prev_center, self.centroid)



# Computes the centroid of the region with opposite corners (r1,c1) and (r2,c2) inclusive
# For testing only
def computeCentroid(P,Q,r1,c1,r2, c2):

  # Inclusive rather than exclusive
  c1 = c1 - 1

  denom = 0
  rNum = 0
  cNum = 0
  for r in range(r1,r2+1,1):
      denom = denom + P[r,c2] - P[r,c1]
      rNum = rNum + (r * (P[r,c2] - P[r,c1]))
      cNum = cNum + (c2*P[r,c2] - Q[r,c2]) - (c1*P[r,c1] - Q[r,c1])

  return support.makeVector(rNum/denom, cNum/denom)    
    
